<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif', 'Helvetica'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz', 'Gill Sans';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono', 'Consolas', 'Courier New'; }
    </style>
  </head>
  <body>
    <textarea id="source">

```tut:invisible

```

class: center, middle

# Typeclass 101: ad hoc polymorphism in scala
Julien Truffaut â€¢ `@JulienTruffaut`

???

- notes here

---
# Instructions


Repository is on github `julien-truffaut/Typeclass`

```
git clone https://github.com/julien-truffaut/Typeclass.git

cd Typeclass

sbt clean test
```

???
- all the code in the slides are compiled using tut
- very few dependencies so it should be fast to download and compile

---

# Ad hoc polymorphism?

```tut:book
1 + 2
3.2 + 4.0

List(1,2,3).map(_ + 1)
Vector(1,2,3).map(_ + 1)
```

???
- overloading a function
- parametric polymorphism: `def take[A](xs: List[A]): List[A]`

---

# Inheritance: OOP implementation

```tut:silent
trait Input {
  def setLabel(s: String): Input
}
case class Text(label: String, maxLength: Int) extends Input {
  def setLabel(s: String): Input = copy(label = s)
}
case class Select(label: String, options: List[String]) extends Input {
  def setLabel(s: String): Input = copy(label = s)
}

val text = Text("What is your name?", maxLength = 20)
val select = Select("Favorite language?", List("scala", "haskell", "purescript"))
```

```tut:book
text.setLabel("foo")
select.setLabel("foo")
```

---

# Inheritance: OOP implementation

```tut:silent
trait Input {
  def setLabel(s: String): Input
}
case class Text(label: String, maxLength: Int) extends Input {
  def setLabel(s: String): Input = copy(label = s)
}
case class Select(label: String, options: List[String]) extends Input {
  def setLabel(s: String): Input = copy(label = s)
}
```

```tut:fail
def _setLabel[A <: Input](a: A, s: String): A = a.setLabel(s)
```

---

# F-Bounded

```tut:silent
trait Input[A <: Input[A]] {
  def setLabel(s: String): A
}
case class Text(label: String, maxLength: Int) extends Input[Text] {
  def setLabel(s: String): Text = copy(label = s)
}
case class Select(label: String, options: List[String]) extends Input[Select] {
  def setLabel(s: String): Select = copy(label = s)
}

def _setLabel[A <: Input[A]](a: A, s: String): A = a.setLabel(s)
```

```tut:silent
case class Radio(label: String, options: List[String]) extends Input[Text] {
  def setLabel(s: String): Text = Text(s, 10) // WTF
}
```
		   
???
- this technique is called F-bounded polymorphism

---

# Self type

```tut:silent
trait Input[A <: Input[A]] { self: A =>
  def setLabel(s: String): A
}
case class Text(label: String, maxLength: Int) extends Input[Text] {
  def setLabel(s: String): Text = copy(label = s)
}
case class Select(label: String, options: List[String]) extends Input[Select] {
  def setLabel(s: String): Select = copy(label = s)
}

def _setLabel[A <: Input[A]](a: A, s: String): A = a.setLabel(s)
```

```tut:fail
case class Radio(label: String, options: List[String]) extends Input[Text] {
  def setLabel(s: String): Text = Text(s, 10)
}
```

---
# Self type

```tut:silent
abstract class Radio(labe: String, options: List[String]) extends Input[Radio]

case class YesNo(label: String) extends Radio(label, List("Yes", "No")) {
  def setLabel(s: String): YesNo = copy(label = s)
}

case class Color(label: String) extends Radio(label, List("Red", "Blue", "Yellow")) {
  def setLabel(s: String): YesNo = YesNo(label = s) // WTF
}
```

???
- `YesNo` and `Color` are both an `Input[Radio]` 
- at this point, I give up with interitance

---
# A typeclass definition in scala

Typeclasses are not first class construct in scala but they generally require the following components:
  
1. typeclass is encoded as a `trait` with one or more type parameters
2. instances of the typeclasses are encoded as `implicit` values of the `trait`
3. syntax to extend all typeclass methods to types with an instance via an `implicit class`
4. laws or properties to define invariants of the typeclass

???
- Typeclass are not a 1st class construct means they are derived from other constructs 
- encoding is not unique, here I will present the most common one used in (scalaz, cats, argonaut, circe, etc ...) 
---
# Trait and companion object

```tut:silent
trait Label[A] {
  def getLabel(a: A): String
  def setLabel(a: A, s: String): A
}

object Label {
  def apply[A](implicit ev: Label[A]): Label[A] = ev
}		   
```
???
- trait or abstract class
- `apply` method is just a short cut to summon an instance, `Label[Text]` instead of `implicitly[Label[Text]]`
---
# Instances

```tut:silent
implicit val labelText: Label[Text] = new Label[Text] {
  def getLabel(a: Text): String = a.label
  def setLabel(a: Text, s: String): Text = a.copy(label = s)
}
```

Instances should be located in:
- companion object of the typeclass (e.g. `Label`) or		   
- companion object of the type (e.g. `Text`)

```tut:book
val text = Text("What is your name?", maxLength = 20)
		   
implicitly[Label[Text]].getLabel(text)

Label[Text].getLabel(text)
Label[Text].setLabel(text, "foo")
```
		   
---
# Syntax

```tut:silent
implicit class LabelOps[A](a: A)(implicit ev: Label[A]){
  def getLabel: String = ev.getLabel(a)
  def setLabel(s: String): A = ev.setLabel(a, s)
}
```

Implicit class is generally located in the companion of the typeclass (e.g. `Label`)

```tut:book
text.getLabel
text.setLabel("foo")
```

???
- this pattern is often refer to pimp a class
- typeclasses permit retroactive extension, i.e. extending types define somewhere else   

---
# Laws

```tut:silent
import scalaprops.{Gen, Properties}
import scalaprops.Properties.properties
import scalaprops.Property
import scalaprops.Property.forAll		   
import scalaz.std.string._

case class LabelLaws[A](implicit A: Label[A]) {
  
  def getSet(implicit genA: Gen[A]): Property  =
    forAll((a: A) => a.setLabel(a.getLabel) == a)

  def setGet(implicit genA: Gen[A], genString: Gen[String]): Property  =
    forAll((a: A, s: String) => a.setLabel(s).getLabel == s)

  def all(implicit genA: Gen[A], genString: Gen[String]): Properties[String] =
    properties("Label")(
     ("getSet", getSet),
     ("setGet", setGet))
}
```
???
- there are more freedom regarding location of laws, some people like to have it in the same file or same module than the typeclass but it requires to add `Scalacheck` or `scalaprop` to your main dependencies. Other people prefer to define them in a separate module or in test

---
# Laws

```tut:silent
import scalaprops.Scalaprops

object TextTest extends Scalaprops {
  implicit val genString: Gen[String] = Gen.asciiString

  implicit val genText: Gen[Text] = for {
    l <- Gen.asciiString
    i <- Gen.choose(1, 100)
  } yield Text(l, i)
	 
  val label = LabelLaws[Text].all
}		 
```

---
# Typeclass + Instance

```tut:silent
trait Label[A] {
  def getLabel(a: A): String
  def setLabel(a: A, s: String): A
}; object Label {
  def apply[A](implicit ev: Label[A]): Label[A] = ev

  implicit class LabelOps[A](a: A)(implicit ev: Label[A]){
    def getLabel: String = ev.getLabel(a)
    def setLabel(s: String): A = ev.setLabel(a, s)
  }
}

case class Text(label: String, maxLength: Int); object Text {
  implicit val label: Label[Text] = new Label[Text]{
    def getLabel(a: Text): String = a.label
    def setLabel(a: Text, s: String): Text = a.copy(label = s)
  }
}
```

---
# Semigroup Exercices

```tut:silent
trait Semigroup[A] {
  def combine(x: A, y: A): A
}
```

1. Implement `SemigroupOps` in `typeclass.syntax.semigroup`
2. Implement associative law in `SemigroupLaws`
3. Implement a `Semigroup` instance for `String`, `Int`, `List[A]`, `Option[A]` in `typeclass.std`
4. Implement a `Semigroup` instance for `NonEmptyList[A]`, `Mult`, `First`, `Last` in `typeclass.data`
	 
run tests using: `sbt exercice/test`

???
- `Semigroup[Int]` is not unique, `+` and `*`. Solution: newtype Mult
- same for `String`: `s1 + s2` or `s2 + s1`
- what about `Option`? `First`, `Last`

---
# Semigroup

```tut:invisible
import typeclass.data.{NonEmptyList, First, Last}
```
```tut:silent
import typeclass.syntax.semigroup._
```

```tut
NonEmptyList(1,2,3).combine(NonEmptyList(4, 5))
First(Option(1)).combine(First(Option(2)))
Last(Option(1)).combine(Last(Option(2)))
```
```tut:fail
"Hello".combine(" World")
```
```tut:silent
import typeclass.std.string._
```

```tut
"Hello".combine(" World")
```

???
- for your own data type, instances are in the companion object => no need of extra import

---
# Monoid Exercices

```tut:silent
trait Monoid[A] extends Semigroup[A] {
  def empty: A

  def isEmpty(a: A): Boolean = ???
  def ifEmpty[B](a: A)(t: => B)(f: => B): B = ???
}
```

1. Derive `isEmpty` and `ifEmpty` implementation from `empty`
2. Write `MonoidOps` in `typeclass.syntax.monoid`
3. Implement left and right identity laws in `MonoidLaws`
3. Implement a `Monoid` instance for `String`, `Int`, `List[A]`, `Option[A]` in `typeclass.std`
4. Implement a `Monoid` instance for `NonEmptyList[A]`, `Mult`, `First`, `Last` in `typeclass.data`

???
- `Monoid[NonEmptyList]` is impossible
	
---
# Typeclass for higher kinded type

TODO

---
# Implicit resolution

TODO

---
# Reduce boiler plate with simulacrum

```tut:silent
import simulacrum._

@typeclass trait Label2[A]{
  def getLabel2(a: A): String
  def setLabel2(a: A, s: String): A
}
		   
implicit val label2Text: Label2[Text] = new Label2[Text] {
  def getLabel2(a: Text): String = a.label
  def setLabel2(a: Text, s: String): Text = a.copy(label = s)
}
```

```tut:invisible
val text = Text.apply("What is your name?", maxLength = 20)
```

```tut:book
import Label2.ops._
text.getLabel2
text.setLabel2("foo")
```

---
class: center, middle

# Thanks!
Code and slides at `julien-truffaut/Typeclass` on GitHub

## Questions?

---

# References

- [tut](https://github.com/tpolecat/tut), [remark.js](https://github.com/gnab/remark), tpolecat [presentation]((https://github.com/tpolecat/cofree/blob/master/tut/slides.html)) I copied from
- [Returning the "Current" Type in Scala](https://tpolecat.github.io/2015/04/29/f-bounds.html) by Rob Norris
- [Type Classes as Objects and Implicits](http://ropas.snu.ac.kr/~bruno/papers/TypeClasses.pdf) by Oliveira, Bruno; Adriaan Moors; Martin Odersky (2010)
















 </textarea>
    <script src="remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
